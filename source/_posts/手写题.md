---
title: 手写题
banner_img: https://cdn.houdemingxin.com/image/default/B380716569044A5DA885EAFA36EE4FAF-6-2.png
date: 2024-06-13 16:22:42
---

## 手写题

##### 实现 Promise.all

```typescript
  //静态方法
  static all(promiseArr) {
    let result = [];
    //声明一个计数器 每一个promise返回就加一
    let count = 0;
    return new Mypromise((resolve, reject) => {
      for (let i = 0; i < promiseArr.length; i++) {
      //这里用 Promise.resolve包装一下 防止不是Promise类型传进来
        Promise.resolve(promiseArr[i]).then(
          (res) => {
            //这里不能直接push数组  因为要控制顺序一一对应(感谢评论区指正)
            result[i] = res;
            count++;
            //只有全部的promise执行成功之后才resolve出去
            if (count === promiseArr.length) {
              resolve(result);
            }
          },
          (err) => {
            reject(err);
          }
        );
      }
    });
  }

```

##### 实现 Promise.finally 10+

```typescript
Promise.prototype.finally = function (callback) {
  return this.then(
    (value) => {
      return Promise.resolve(callback()).then(() => {
        return value;
      });
    },
    (err) => {
      return Promise.resolve(callback()).then(() => {
        throw err;
      });
    }
  );
};
```

##### 实现 Promise.allSettled 5-10

```typescript
Promise.allSettled = function (promiseArr) {
  let result = [];
  return new Promise((resolve, reject) => {
    promiseArr.forEach((p, i) => {
      Promise.resolve(p).then(
        (val) => {
          result.push({
            status: "fulfilled",
            value: val,
          });
          if (result.length === promiseArr.length) {
            resolve(result);
          }
        },
        (err) => {
          result.push({
            status: "rejected",
            reason: err,
          });
          if (result.length === promiseArr.length) {
            resolve(result);
          }
        }
      );
    });
  });
};
```

##### 实现 Promise.race 3-5

```typescript
  //静态方法
  static race(promiseArr) {
    return new Mypromise((resolve, reject) => {
      for (let i = 0; i < promiseArr.length; i++) {
        Promise.resolve(promiseArr[i]).then(
          (res) => {
            //promise数组只要有任何一个promise 状态变更  就可以返回
            resolve(res);
          },
          (err) => {
            reject(err);
          }
        );
      }
    });
  }
}

```

##### 数组去重 10+

```typescript
//reduce + includes 去重
function uniq(arr) {
  return arr.reduce((prev, next) => {
    if (!prev.includes(next)) {
      prev.push(next);
    }
    return prev;
  }, []);
}
console.log(uniq(arr));

function unq(arr) {
  return arr.reduce((prev, next) => {
    if (!prev.includes(next)) {
      prev.push(next);
    }
    return prev;
  }, []);
}
```

##### 数组扁平化 10+

```typescript
function flot(arr) {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flot(arr[i]));
    } else {
      retult = result.push(arr[i]);
    }
  }
  return result;
}
function flot(arr) {
  return arr.reduce((prev, next) => {
    return prev.concat(Array.isArray(next) ? flat(next) : next);
  }, []);
}
```

##### 手写 ForEach 3-5

```typescript
Array.prototype.myForEach = function (fn) {
  let arr = [...this];
  for (let i = 0; i < arr.length; i++) {
    fn(arr[i], i, arr);
  }
};
```

##### 手写 Reduce 3-5

```typescript
Array.prototype.myReduce = function (fn, params) {
  let arr = [...this];
  let index = 0;
  let prev = params;
  if (!params) {
    index = 1;
    prev = arr[0];
  }
  for (let i = 0; i < arr.length; i++) {
    prev = fn(prev, arr[i], i, arr);
  }
  return prev;
};
```

##### 实现防抖 debounce 10+

```typescript
function debounce(fn, time) {
  //要限制防抖的函数,限制时间
  let timer = null;
  return function () {
    if (!timer) {
      clearInterval(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments); //当前this指向btn，实参集合
    }, time);
  };
}
```

##### 实现节流函数 throttle 10+

```typescript
function throttle(fn, time) {
  let date = 0;
  return function () {
    let newDate = new Date().getTime();
    if (newDate - date > time) {
      fn.apply(this, arguments);
      date = newDate;
    }
  };
}
```

##### 写一个完整的深拷贝 10+

```typescript
 function deepClone(obj) {
        let newObj = obj instancef Array ? [] : {}  //判断传入的值是不是数组 true?[]:{}
        if (obj && typeof obj === "object") {  //判断传入的值是不是object
            for (const key in obj) { //如果是for in 循环
                if (obj.hasOwnProperty(key)) {  //
                    if (obj[key] && typeof obj[key] === 'object') {
                        newObj[key] = deepClone(obj[key])
                    } else {
                        newObj[key] = obj[key]
                    }
                }
            }
        }
        return newObj  //不是 直接返回
    }
    let a = [1, 2, 3, 4, 5]
    let b = deepClone(a)
    a[0] = 2
    console.log(a, b);
```

##### 实现 new 关键字编写 10+

```typescript
function objectFactory() {
  var obj = new Object();
  Constructor = Array.prototype.shift.call(arguments);
  obj.__proto__ = Constructor.prototype;
  var ret = Constructor.apply(obj, arguments);

  // ret || obj 这里这么写考虑了构造函数显示返回 null 的情况
  return typeof ret === "object" ? ret || obj : obj;
}
//使用
function person(name, age) {
  this.name = name;
  this.age = age;
}
let p = objectFactory(person, "布兰", 12);
console.log(p); // { name: '布兰', age: 12 }
```

##### Es5 实现继承&Es6 实现继承 10+

```typescript
// 原型链继承
function Animal() {
  this.colors = ["black", "white"];
}
Animal.prototype.getColor = function () {
  return this.colors;
};
function Dog() {}
Dog.prototype = new Animal();

let dog1 = new Dog();
dog1.colors.push("brown");
let dog2 = new Dog();
console.log(dog2.colors); // ['black', 'white', 'brown']

// 组合继承
function Animal(name) {
  this.name = name;
  this.colors = ["black", "white"];
}
Animal.prototype.getName = function () {
  return this.name;
};
function Dog(name, age) {
  Animal.call(this, name);
  this.age = age;
}
Dog.prototype = new Animal();
Dog.prototype.constructor = Dog;

let dog1 = new Dog("奶昔", 2);
dog1.colors.push("brown");
let dog2 = new Dog("哈赤", 1);
console.log(dog2);
// { name: "哈赤", colors: ["black", "white"], age: 1 }

// 借用构造函数(经典继承)
function Animal(name) {
  this.name = name;
  this.getName = function () {
    return this.name;
  };
}
function Dog(name) {
  Animal.call(this, name);
}
Dog.prototype = new Animal();

// 寄生组合式继承
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
function inheritPrototype(child, parent) {
  let prototype = object(parent.prototype);
  prototype.constructor = child;
  child.prototype = prototype;
}
inheritPrototype(Dog, Animal);
//class实现继承
class Animal {
  constructor(name) {
    this.name = name;
  }
  getName() {
    return this.name;
  }
}
class Dog extends Animal {
  constructor(name, age) {
    super(name);
    this.age = age;
  }
}
```

##### 手写 Call 10+

```typescript
function Person() {
  console.log(this.name, a, b, c, d);
}
let egg = {
  name: "小雅",
};
// 封装mycall
Function.prototype.mycall = function (obj) {
  obj = obj || window; //这里注意this不能指向null
  let newArgs = []; //需要拿到每一个arguments集合
  obj.fn = this;
  for (let i = 1; i < arguments.length; i++) {
    //循环arguments集合,这里从下标1开始，第0项是this指向
    newArgs.push(`arguments[${i}]`);
  }
  let res = eval(`obj.fn(${newArgs})`);
  delete obj.fn;
  return res;
};
console.log(Person.mycall(egg, {}, 2, 3, 4));
Person.call(egg, {}, 2, 3, 4);
Function.prototype.mycall = function (obj) {
  obj = obj || window;
  obj.fn = this;

  delete obj.fn;
};
```

##### 手写 Apply 10+

```typescript
function Person(a, b) {
  console.log(this.name, a, b);
  // return 123
}
let egg = {
  name: "小雅",
};
//封装myapply
/*
        1.需要注意的是第二个参数
        2.this指向问题
        3.返回值
        4.this为null时
    */
Function.prototype.myapply = function (obj, args) {
  obj = obj || window; //这里注意this不能指向null
  let newArgs = []; //需要拿到每一个arguments集合
  let res = null;
  obj.fn = this;
  if (!args) {
    // 如果没有传第二个参数 直接返回当前的方法
    res = obj.fn();
  } else {
    //如果有 循环遍历把每一项放到一个空数组里 然后使用eval()函数 将方法调用并传入新数组
    for (let i = 0; i < args.length; i++) {
      //循环arguments集合,这里从下标1开始，第0项是this指向
      newArgs.push(`args[${i}]`);
    }
    res = eval(`obj.fn(${newArgs})`);
  }
  delete obj.fn; //删除当前的方法
  return res; //返回值
};
Person.myapply(egg, [1, "2"]);
Person.apply(egg, [1, "2"]);
```

##### 手写 bind 10+

```typescript
function Person(a, b) {
  console.log(this.name, a, b);
  // return 123
}
let egg = {
  name: "小雅",
};

//封装bind方法
Function.prototype.mybind = function (obj) {
  let args = Array.prototype.slice.call(arguments, 1); //将伪数组转化为数组 arguments调用此方法 1 从下标1开始
  let arg = null;
  console.log(this);
  let that = this; //获取到当前函数的this指向
  return function () {
    //闭包的方式返回一个函数  //这里为es5方法 es6 ()=>{} this继承父级 但是下边那个打印结果有问题，咱也不知道为啥
    console.log(this);
    arg = Array.prototype.slice.call(arguments);
    that.apply(obj, [...args, ...arg]); //这里考虑到了函数内部的值 合并一下参数
  };
};
Person.mybind(egg, 1)(2); //调用的时候为柯函数里化
```

##### 实现柯里化函数 3-5

```typescript
function curry(fn, currArgs) {
  // 这里的fn就是sum方法
  return function () {
    let args = Array.prototype.slice.call(arguments);
    console.log(fn, currArgs);
    // 首次调用时未提供参数currArgs，因此不用进行拼接执行
    if (currArgs) {
      args = args.concat(currArgs); // 这里的currArgs是上次递归传递进来的，也就是上次递归的args
    }
    // 递归调用
    if (args.length < fn.length) {
      return curry(fn, args);
    }
    console.log(args);
    return fn.apply(this, args); // 这里调用了apply方法，将收集起来的args参数全都传入fn中
  };
}
function sum(a, b, c, d, e) {
  return a + b + c + d + e;
}
const fn = curry(sum);
console.log(fn(1)(2)(3)(4)(5)); //  6
console.log(fn(1)(2, 3)(4, 5)); // 6
console.log(fn(1, 2, 3, 4, 5)); //6
```

##### 实现 jsonp 3-5

```typescript
const jsonp = ({ url, params, callbackName }) => {
  const generateUrl = () => {
    let dataSrc = "";
    for (let key in params) {
      if (params.hasOwnProperty(key)) {
        dataSrc += `${key}=${params[key]}&`;
      }
    }
    dataSrc += `callback=${callbackName}`;
    return `${url}?${dataSrc}`;
  };
  return new Promise((resolve, reject) => {
    const scriptEle = document.createElement("script");
    scriptEle.src = generateUrl();
    document.body.appendChild(scriptEle);
    window[callbackName] = (data) => {
      resolve(data);
      document.removeChild(scriptEle);
    };
  });
};
```

##### 实现 instanceOf 3-5

```typescript
function instanceOf(left, right) {
  let proto = left.__proto__;
  while (true) {
    if (proto === null) return false;
    if (proto === right.prototype) {
      return true;
    }
    proto = proto.__proto__;
  }
}
```
